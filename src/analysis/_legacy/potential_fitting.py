"""
potential_fitting.py
--------------------
This script fits an effective potential model to a radial profile of the entanglement curvature field,
then outputs both a figure (PNG) and a small CSV with the fit parameters, uncertainties, and residual metrics.

It loads a CSV file (generated by radial_profile.py) which contains:
    - radial_bin_center: the center of the radial bin.
    - mean_laplacian: the mean Laplacian (curvature proxy) in that bin.
    - std_laplacian: standard deviation in the bin.
    - count: number of points in the bin.

Models:
    1. Yukawa (default): Phi(r) = A * exp(-r/lambda) / r
    2. Gaussian:         Phi(r) = A * exp(-r^2/(2*sigma^2))

Outputs:
    - A figure in PNG format with a timestamp prefix (placed in `--output-dir`, default ../../data/figures/).
    - A parameter summary CSV, also timestamped, in the same directory.

Author: The HoloCosmo Project
Date: April 2025
"""

import argparse
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from datetime import datetime
import os

def parse_arguments():
    parser = argparse.ArgumentParser(description="Fit an effective potential to radial curvature data.")
    parser.add_argument("--input-file", type=str, required=True,
                        help="Path to the radial profile CSV file.")
    parser.add_argument("--model", type=str, default="yukawa", choices=["yukawa", "gaussian"],
                        help="Choose the fit model: 'yukawa' (default) or 'gaussian'.")
    parser.add_argument("--output-file", type=str, default="potential_fit.png",
                        help="Base name for the output figure file (prefix will be added).")
    parser.add_argument("--output-dir", type=str, default="../../data/figures/",
                        help="Output directory for the figure and CSV.")
    return parser.parse_args()

def yukawa_model(r, A, lam):
    """Yukawa potential model: Phi(r) = A * exp(-r/lam) / r"""
    r_safe = np.where(r == 0, 1e-6, r)  # avoid division by zero
    return A * np.exp(-r_safe / lam) / r_safe

def gaussian_model(r, A, sigma):
    """Gaussian potential model: Phi(r) = A * exp(-r^2/(2*sigma^2))"""
    return A * np.exp(-r**2 / (2*sigma**2))

def fit_potential(r, y, model_type="yukawa"):
    """
    Fit the chosen model to (r, y) data. Filter out any NaN/inf first.
    Returns (popt, pcov, model_func).
    """
    # Filter invalid entries
    valid = np.isfinite(r) & np.isfinite(y)
    r_valid = r[valid]
    y_valid = y[valid]

    if len(r_valid) < 2:
        raise ValueError("Not enough valid data points to fit a potential.")

    if model_type == "yukawa":
        # p0 guess: amplitude ~ y at smallest r, lam ~ half the max r
        p0 = [y_valid[0] if y_valid[0] != 0 else 1e-3, r_valid.max() / 2]
        popt, pcov = curve_fit(yukawa_model, r_valid, y_valid, p0=p0, maxfev=10000)
        return popt, pcov, yukawa_model

    elif model_type == "gaussian":
        # p0 guess: amplitude ~ y near r=0, sigma ~ half the max r
        p0 = [y_valid[0] if y_valid[0] != 0 else 1e-3, r_valid.max() / 2]
        popt, pcov = curve_fit(gaussian_model, r_valid, y_valid, p0=p0, maxfev=10000)
        return popt, pcov, gaussian_model

    else:
        raise ValueError("Unknown model type")

def main():
    args = parse_arguments()

    # Load radial profile data
    print("Loading data from", args.input_file)
    df = pd.read_csv(args.input_file)
    r = df["radial_bin_center"].values
    y = df["mean_laplacian"].values

    # Fit the chosen model
    print(f"Fitting the {args.model} model...")
    popt, pcov, model_func = fit_potential(r, y, model_type=args.model)
    # popt are best-fit params, pcov is the covariance matrix

    # Extract parameter errors (approx 1-sigma)
    perr = np.sqrt(np.diag(pcov))

    # Evaluate the fitted function for a smooth curve
    r_fit = np.linspace(r.min(), r.max(), 200)
    y_fit = model_func(r_fit, *popt)

    # Compute residuals on valid data
    valid = np.isfinite(r) & np.isfinite(y)
    residuals = y[valid] - model_func(r[valid], *popt)
    rmse = np.sqrt(np.mean(residuals**2))

    # Print results to console
    print(f"Fitted parameters: {popt}")
    print(f"Std dev errors   : {perr}")
    print(f"RMSE of fit      : {rmse:.5f}")

    # Plot
    fig = plt.figure(figsize=(8, 6))
    plt.errorbar(r, y, yerr=df.get("std_laplacian", None), fmt='o', label='Data', capsize=3)
    plt.plot(r_fit, y_fit, 'r-', label=f'Fitted {args.model} model')
    plt.xlabel("Radial Distance")
    plt.ylabel("Mean Laplacian")
    plt.title("Effective Potential Fit from Radial Curvature Data")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()

    # Prepare output figure filename with timestamp
    timestamp = datetime.now().strftime("%Y%m%d-%H%M")
    basename = os.path.basename(args.output_file).replace(".png", "")
    fig_filename = f"{timestamp}_{basename}.png"
    os.makedirs(args.output_dir, exist_ok=True)
    fig_path = os.path.join(args.output_dir, fig_filename)
    fig.savefig(fig_path)
    print(f"Figure saved to {os.path.abspath(fig_path)}")

    # Save fit results to CSV
    result_filename = f"{timestamp}_{basename}_params.csv"
    result_path = os.path.join(args.output_dir, result_filename)

    # We'll store model, param names, values, errors, RMSE
    if args.model == "yukawa":
        param_names = ["A", "lambda"]
    else:
        param_names = ["A", "sigma"]

    rows = []
    for name, val, err in zip(param_names, popt, perr):
        rows.append({
            "model": args.model,
            "parameter": name,
            "value": val,
            "error": err,
            "rmse": rmse
        })

    pd.DataFrame(rows).to_csv(result_path, index=False)
    print(f"Fit parameters CSV saved to {os.path.abspath(result_path)}")

    plt.show()

if __name__ == "__main__":
    main()
